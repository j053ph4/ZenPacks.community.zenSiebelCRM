import logging
log = logging.getLogger('zen.zensiebelperf')

import Globals
import zope.component
import zope.interface
from twisted.internet import base, defer, reactor
from twisted.python.failure import Failure
from Products.ZenCollector.daemon import CollectorDaemon
from Products.ZenCollector.interfaces import ICollectorPreferences, IScheduledTask, IEventService, IDataService
from Products.ZenCollector.tasks import SimpleTaskFactory, SimpleTaskSplitter, TaskStates
from Products.ZenEvents.Event import Warning, Clear
from Products.ZenUtils.observable import ObservableMixin
from Products.ZenUtils.Utils import unused
from ZenPacks.community.zenSiebelCRM.SiebelHandler import SiebelHandler
from ZenPacks.community.zenSiebelCRM.services.SiebelConfigService import SiebelConfigService

unused(Globals)
unused(SiebelConfigService)

from Products.ZenUtils.Driver import drive

class ZenSiebelPreferences(object):
    zope.interface.implements(ICollectorPreferences)

    def __init__(self):
        self.collectorName = 'zensiebelperf'
        self.configurationService = "ZenPacks.community.zenSiebelCRM.services.SiebelConfigService"
        self.cycleInterval = 5 * 60
        self.configCycleInterval = 5 * 60
        self.options = None
        self.siebelclients = []

    def buildOptions(self, parser):
        """
        Required to implement the ICollectorPreferences interface.
        """
        parser.add_option('--shareGateways', dest='shareGateways',
                        action='store_true', default=True,
                        help='If enabled, devices with same gateway/enterprise will share session'  
                        ) 
        parser.add_option('--maxPerGateway', dest='maxPerGateway',
                        default=8, type='int',
                        help='Number of servers haring a single session if shareGateway is enabled'
                        )

    def postStartup(self):
        """
        Required to implement the ICollectorPreferences interface.
        """
        pass
    
    def getSiebelClients(self):
        return self.siebelclients
    
    def shareGateway(self):
        return self.options.shareGateways
    
    def maxPerGateway(self):
        return self.options.maxPerGateway

class ZenSiebelTask(ObservableMixin):
    zope.interface.implements(IScheduledTask)

    STATE_CONNECTING = 'CONNECTING'
    STATE_COLLECTING = 'COLLECTING'
    CLEAR_EVENT = dict(component="zensiebelperf", severity=Clear, eventClass='/App/Siebel')
    WARNING_EVENT = dict(component="zensiebelperf", severity=Warning, eventClass='/App/Siebel')

    def __init__(self, taskName, deviceId, interval, taskConfig):
        super(ZenSiebelTask, self).__init__()
        self._taskConfig = taskConfig
        self._eventService = zope.component.queryUtility(IEventService)
        self._dataService = zope.component.queryUtility(IDataService)
        self._preferences = zope.component.queryUtility(ICollectorPreferences, 'zensiebelperf')
        self._taskConfig = taskConfig
        
        self.shareGateway = self._preferences.shareGateway()
        self.maxPerGateway = self._preferences.maxPerGateway()
        # All of these properties are required to implement the IScheduledTask
        # interface
        self.name = taskName
        self.configId = deviceId
        self.interval = interval
        self.state = TaskStates.STATE_IDLE

        self._devId = deviceId
        self._manageIp = self._taskConfig.manageIp
        self.siebelClient = None

    def _connect(self):
        """
            Connect to the Siebel device asynchronously.
        """
        log.info("Connecting to %s [%s]", self._devId, self._manageIp)
        self.state = ZenSiebelTask.STATE_CONNECTING
        self.siebelClient = self.recycleConnection()
        if self.siebelClient not in self._preferences.siebelclients:
            self._preferences.siebelclients.append(self.siebelClient)
        log.info("running %s concurrent srvrmgr sessions",len(self._preferences.siebelclients))
        return self.configure()
    
    def _connectCallback(self, result):
        """
        Callback for a successful asynchronous connection request.
        """
        log.info("Connected to %s [%s]", self._devId, self._manageIp)

    def _failure(self, result):
        """
        Errback for an unsuccessful asynchronous connection or collection
        request.
        """
        err = result.getErrorMessage()
        log.error("Unable to scan device %s: %s", self._devId, err)
        self._eventService.sendEvent(ZenSiebelTask.WARNING_EVENT,
                                     device=self._devId,
                                     summary="Error collecting performance data: %s" % err)
        self._resetHard()
        return result

    def _reset(self):
        """
            Reset a srvrmgr connection and collection stats so that collection
            can start over from scratch.
        """
        if self._taskConfig.zSiebelUseGateway == True: # if session sharing enabled
#            # check and see if this session has been used too many times
#            timesRun = self.siebelClient.timesRun / len(self._preferences.siebelclients)
#            if timesRun > self._taskConfig.cyclesPerConnection:
#                log.info("Resetting connection to %s",self._devId)
#                self._resetHard()
            log.info("Releasing connection to %s",self._devId)
            self.siebelClient.timesRun += 1
        else:
            log.info("Terminating connection to %s",self._devId)
            self._resetHard()
#            if self.siebelClient:
#                self.siebelClient.terminate()
#            self.siebelClient = None
        #return defer.succeed(None)
    
    def _resetHard(self):
        """
        Terminate srvrmgr connection and remove from list of sessions
        """
        log.info("Terminating connection to %s",self._devId)
        if self.siebelClient:
            self.siebelClient.terminate()
            if self.siebelClient in self._preferences.siebelclients:
                self._preferences.siebelclients.remove(self.siebelClient)
        self.siebelClient = None
        return defer.succeed(None)

    def _collectSuccessful(self, result):
        """
        Callback for a successful asynchronous performance data collection
        request.
        """
        log.debug("Successful collection from %s [%s], result=%s",self._devId, self._manageIp, result)

        for compId,dsDict in result.items():
            for dsId,compDict in dsDict.items():
                for dpId,dpValue in compDict.items():
                    try:
                        dpDict = self._taskConfig.datasources[compId][dsId][dpId]
                        self._dataService.writeRRD(dpDict['path'],
                                                    dpValue,
                                                    dpDict['rrdType'],
                                                    rrdCommand=dpDict['rrdCmd'],
                                                    cycleTime=self.interval,
                                                    min=dpDict['minv'],
                                                    max=dpDict['maxv'])
                    except Exception:
                        log.exception("Unable to write datapoint for command [%s] on device %s [%s]",
                                      compDict['command'], self._devId, self._manageIp)

        self._eventService.sendEvent(ZenSiebelTask.CLEAR_EVENT,
                                     device=self._devId,
                                     summary="Device collected successfully")

        log.info("Successful scan of %s [%s] (%d datasources)",
                  self._devId, self._manageIp,len(result.keys()))

    def _collectCallback(self, result):
        """
            Callback used to begin performance data collection asynchronously after
            a connection or task setup.
        """
        if self.siebelClient:
            self.state = ZenSiebelTask.STATE_COLLECTING
            log.info("Collecting data for %s [%s]", self._devId,
                      self._manageIp)
            d = self.fetch()
            d.addCallbacks(self._collectSuccessful, self._failure)
            return d

    def _finished(self, result):
        """ 
            post collection activities
        """
        if not isinstance(result, Failure):
            log.info("Successful scan of %s [%s] completed",
                      self._devId, self._manageIp)
        else:
            log.error("Unsuccessful scan of %s [%s] completed, result=%s",
                      self._devId, self._manageIp, result.getErrorMessage())
            self._eventService.sendEvent(ZenSiebelTask.WARNING_EVENT,
                                     device=self._devId,
                                     summary="Unsuccessful scan: %s" % result.getErrorMessage())
        self._reset()
        return result
    
    def getTasks(self,data):
        """ retrieve task status for an individual component
        """
        log.info("getting tasks for for %d",self._devId)
        numTasks = 0
        goodTasks = 0
        badTasks = 0
        try:
            entries = len(data[data.keys()[0]])
            numTasks = entries
            for i in range(entries):
                taskStatus = data['TK_DISP_RUNSTATE'][i].upper()
                if (taskStatus == 'RUNNING' or taskStatus == 'COMPLETED'  or taskStatus == 'ONLINE'):
                    goodTasks += 1
                else:
                    badTasks += 1
        except:
            pass
        return numTasks,goodTasks,badTasks
    
    def getRunState(self,data):
        """ find the run status of this component
        """
        log.info("getting run state for for %d",self._devId)
        try:
            runstate = data['CP_DISP_RUN_STATE'][0]
            
            if runstate == 'Online':
                return 3
            elif runstate == 'Running':
                return 4
            elif runstate == 'Unavailable':
                return 2
            elif runstate == 'Stopped':
                return 1
            elif runstate == 'Shutdown':
                return 0
        except:
            return -1
        
    def createConnection(self):
        """ create a new srvrmgr connection
        """
        log.info("creating new session for gtwy: %s and ent %s",self._taskConfig.zSiebelGateway.upper(),self._taskConfig.zSiebelEnterprise.upper())
        session = SiebelHandler()
        session.initialize(self._taskConfig.zSiebelGateway,
                           self._taskConfig.zSiebelEnterprise,
                           self._taskConfig.zSiebelServer,
                           self._taskConfig.zSiebelUser,
                           self._taskConfig.zSiebelPassword,
                           self._taskConfig.timeoutSeconds,
                           self.shareGateway)
        return session
        
    def recycleConnection(self):
        """ 
            Determine if a srvrmgr session exists and can be used 
            or if a new one should be created
        """
        if self.shareGateway == True:
            log.info("sharing gateway, checking %s running sessions",len(self._preferences.siebelclients))
            for client in self._preferences.getSiebelClients():
                if client.gateway.upper() == self._taskConfig.zSiebelGateway.upper() and client.enterprise.upper() == self._taskConfig.zSiebelEnterprise.upper():
                    if client.servers < self.maxPerGateway and client.connected == True:
                        log.info("recycling session with %s servers for gtwy: %s and ent %s", 
                                 client.servers,
                                 client.gateway.upper(),
                                 client.enterprise.upper())
                        client.servers += 1
                        return client
        return self.createConnection()

    def configure(self):
        """
        """
        def inner(driver):
            log.debug("Configuring connection to server: %s gtwy: %s ent: %s",
                      self.siebelClient.server.upper(),
                      self.siebelClient.gateway.upper(),
                      self.siebelClient.enterprise.upper())
            if self.siebelClient.connected == True:
                yield defer.succeed(None)
            else:
                yield defer.fail("Not connected to %s" % self._devId)
        return drive(inner)

    def cleanup(self):
        """
        """
        log.info("performing cleanup tasks")
        self._resetHard()
    
    def doTask(self):
        """
        """
        log.info("Scanning device %s [%s]", self._devId, self._manageIp)
        if not self.siebelClient:
            d = self._connect()
            d.addCallbacks(self._connectCallback, self._failure)
        else:
            d = defer.Deferred()
            reactor.callLater(0, d.callback, None)

        d.addCallback(self._collectCallback)
        d.addBoth(self._finished)
        return d
    
    def fetch(self):
        """
            Main data collection routine, loops though data sources, updating each one
            after executing datasource commands
        """   
        def inner(driver):
            result = {}
            if self.shareGateway == True:
                self.siebelClient.setServer(self._taskConfig.zSiebelServer)
            if self.siebelClient.connected == True:
                log.info("Executing commands for %s [%s] (%d datasources)", self._devId, self._manageIp,len(self._taskConfig.datasources.items()))
                for compId,dsDict in self._taskConfig.datasources.items():
                    result[compId] = {}
                    for dsId,compDict in dsDict.items():
                        command = compDict['command']
                        sourcetype = compDict['sourcetype']
                        #log.debug("Executing command: %s",command)
                        output = self.siebelClient.getCommandOutput(command)
                        result[compId][dsId] = {}
                        if sourcetype == 'SiebelStatus': # collect the status of each component
                            runState = self.getRunState(output)
                            result[compId][dsId]['runState'] = runState
                        if sourcetype == 'SiebelTasks': # analyze the stats for each component
                            numTasks,goodTasks,badTasks = self.getTasks(output)
                            result[compId][dsId]['numTasks'] = numTasks
                            result[compId][dsId]['goodTasks'] = goodTasks
                            result[compId][dsId]['badTasks'] = badTasks
                        if sourcetype == 'SiebelPerf': # collect performance data for each component
                            dataItems = self.siebelClient.statDict(output,'STAT_ALIAS','CURR_VAL')
                            for dpId,dpValue in dataItems.items():
                                result[compId][dsId][dpId] = dpValue
                if self.shareGateway == True:
                    self.siebelClient.unsetServer()         
            else:
                log.warn("not connected to %s",self._devId)

            yield defer.succeed(result)
            #else:
                #yield defer.fail("Fetch Failed: Not connected to %s" % self._taskConfig.zSiebelServer)
        return drive(inner)
     
if __name__ == '__main__':
    myPreferences = ZenSiebelPreferences()
    myTaskFactory = SimpleTaskFactory(ZenSiebelTask)
    myTaskSplitter = SimpleTaskSplitter(myTaskFactory)
    daemon = CollectorDaemon(myPreferences, myTaskSplitter)
    daemon.run()

